<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>JaimeDiagramas - Editor de Diagramas ER</title>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css" />
		<style>
			body {
				margin: 0;
				overflow: hidden;
				font-family: "Inter", system-ui, -apple-system, sans-serif;
			}

			.toolbar {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				z-index: 1000;
			}

			.btn {
				transition: all 0.2s ease;
				font-weight: 500;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			}

			.btn:hover {
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
			}

			.btn:active {
				transform: translateY(0);
			}

			#container {
				width: 100vw;
				height: calc(100vh - 72px);
				background-color: #f8fafc;
			}

			/* Context Menu Styles */
			.context-menu {
				position: absolute;
				background: white;
				border-radius: 8px;
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
				padding: 8px 0;
				min-width: 180px;
				z-index: 10000;
			}

			.context-menu-item {
				padding: 10px 16px;
				cursor: pointer;
				display: flex;
				align-items: center;
				gap: 10px;
				transition: background 0.15s;
				font-size: 14px;
				color: #1f2937;
			}

			.context-menu-item:hover {
				background: #f3f4f6;
			}

			.context-menu-item i {
				width: 16px;
				text-align: center;
			}

			.context-menu-divider {
				height: 1px;
				background: #e5e7eb;
				margin: 4px 0;
			}

			/* SweetAlert2 Custom Styles */
			.swal2-popup {
				font-family: "Inter", system-ui, -apple-system, sans-serif;
			}

			.swal2-title {
				color: #1f2937;
				font-weight: 600;
			}

			.swal2-html-container {
				color: #4b5563;
			}

			.swal2-input {
				border: var(--swal2-input-border);
				border-radius: var(--swal2-input-border-radius);
			}

			/* Error Modal Styles */
			.error-item {
				padding: 12px;
				border-radius: 6px;
				margin-bottom: 8px;
				display: flex;
				align-items: start;
				gap: 10px;
			}

			.error-item.error {
				background: #fee2e2;
				border-left: 4px solid #ef4444;
			}

			.error-item.warning {
				background: #fef3c7;
				border-left: 4px solid #f59e0b;
			}

			.error-item-icon {
				font-size: 18px;
				margin-top: 2px;
			}

			.error-item.error .error-item-icon {
				color: #dc2626;
			}

			.error-item.warning .error-item-icon {
				color: #d97706;
			}

			.error-item-content {
				flex: 1;
			}

			.error-item-title {
				font-weight: 600;
				margin-bottom: 4px;
				font-size: 14px;
			}

			.error-item-message {
				font-size: 13px;
				color: #4b5563;
			}

			/* Dropdown Menu */
			.dropdown-menu {
				position: absolute;
				background: white;
				border-radius: 6px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
				padding: 4px 0;
				min-width: 150px;
				z-index: 1000;
			}

			.dropdown-item {
				padding: 8px 12px;
				cursor: pointer;
				font-size: 13px;
				color: #374151;
				transition: background 0.15s;
			}

			.dropdown-item:hover {
				background: #f3f4f6;
			}

			.dropdown-item i {
				margin-right: 8px;
				width: 14px;
			}
		</style>
	</head>
	<body class="bg-gray-50">
		<div class="toolbar shadow-lg p-4 flex items-center justify-between">
			<div class="flex items-center gap-4">
				<h1 class="text-white text-2xl font-bold flex items-center gap-2">
					<i class="fas fa-project-diagram"></i>
					JaimeDiagramas
				</h1>
			</div>

			<div class="flex gap-2">
				<button id="addEntityBtn" class="btn bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg flex items-center gap-2"><i class="fas fa-table"></i> Nueva Entidad</button>
				<button id="addRelationshipBtn" class="btn bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-lg flex items-center gap-2"><i class="fas fa-link"></i> Nueva Relaci칩n</button>
				<button id="resetViewBtn" class="btn bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg flex items-center gap-2"><i class="fas fa-crosshairs"></i> Centrar Vista</button>
				<button id="errorsBtn" class="btn bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg flex items-center gap-2"><i class="fas fa-exclamation-triangle"></i> Errores</button>
				<button id="exportSQLBtn" class="btn bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg flex items-center gap-2"><i class="fas fa-database"></i> Exportar SQL</button>
			</div>
		</div>

		<div id="container"></div>

		<script src="https://cdn.jsdelivr.net/npm/konva@9/konva.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
		<script>
			// Import Konva and Swal
			const Konva = window.Konva;
			const Swal = window.Swal;

			// Global state
			let stage, layer, gridLayer;
			let entities = [];
			let relationships = [];
			let properties = [];
			let connections = [];

			const CANVAS_WIDTH = 4000;
			const CANVAS_HEIGHT = 4000;
			const GRID_SIZE = 30;

			// Initialize Konva stage
			function initStage() {
				const container = document.getElementById("container");
				const width = container.offsetWidth;
				const height = container.offsetHeight;

				stage = new Konva.Stage({
					container: "container",
					width: width,
					height: height,
					draggable: true, // Disable stage dragging
				});

				// Grid layer
				gridLayer = new Konva.Layer();
				drawGrid();
				stage.add(gridLayer);

				// Main layer
				layer = new Konva.Layer();
				stage.add(layer);

				centerView();

				// Mouse wheel zoom
				stage.on("wheel", (e) => {
					e.evt.preventDefault();

					const oldScale = stage.scaleX();
					const pointer = stage.getPointerPosition();

					const mousePointTo = {
						x: (pointer.x - stage.x()) / oldScale,
						y: (pointer.y - stage.y()) / oldScale,
					};

					const scaleBy = 1.1;
					const newScale = e.evt.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;

					// Limit zoom
					if (newScale < 0.3 || newScale > 3) return;

					stage.scale({ x: newScale, y: newScale });

					const newPos = {
						x: pointer.x - mousePointTo.x * newScale,
						y: pointer.y - mousePointTo.y * newScale,
					};

					stage.position(newPos);
					stage.batchDraw();
				});

				// Right-click on empty space
				stage.on("contextmenu", (e) => {
					if (e.target === stage || e.target.getLayer() === gridLayer) {
						e.evt.preventDefault();
						showEmptySpaceContextMenu(e.evt.clientX, e.evt.clientY);
					}
				});
			}

			function drawGrid() {
				gridLayer.destroyChildren();

				// Grid lines
				for (let i = 0; i < CANVAS_WIDTH / GRID_SIZE; i++) {
					gridLayer.add(
						new Konva.Line({
							points: [i * GRID_SIZE, 0, i * GRID_SIZE, CANVAS_HEIGHT],
							stroke: "#cbd5e1",
							strokeWidth: 1,
						})
					);
				}

				for (let i = 0; i < CANVAS_HEIGHT / GRID_SIZE; i++) {
					gridLayer.add(
						new Konva.Line({
							points: [0, i * GRID_SIZE, CANVAS_WIDTH, i * GRID_SIZE],
							stroke: "#cbd5e1",
							strokeWidth: 1,
						})
					);
				}

				// 游댳 Border (thick but subtle)
				gridLayer.add(
					new Konva.Rect({
						x: 0,
						y: 0,
						width: CANVAS_WIDTH,
						height: CANVAS_HEIGHT,
						stroke: "#94a3b8", // m치s tenue que la cuadr칤cula
						strokeWidth: 4, // m치s grueso
					})
				);

				// 游댳 Concentric circles
				const centerX = CANVAS_WIDTH / 2;
				const centerY = CANVAS_HEIGHT / 2;
				const maxRadius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;

				for (let r = GRID_SIZE * 5; r < maxRadius; r += GRID_SIZE * 5) {
					gridLayer.add(
						new Konva.Circle({
							x: centerX,
							y: centerY,
							radius: r,
							stroke: "#eee", // m치s claro que las l칤neas del grid
							strokeWidth: 3,
							dash: [12, 12], // opcional: lo hace m치s sutil
						})
					);
				}

				gridLayer.batchDraw();
			}

			function centerView() {
				const scale = 1;
				stage.scale({ x: scale, y: scale });
				stage.position({
					x: (stage.width() - CANVAS_WIDTH * scale) / 2,
					y: (stage.height() - CANVAS_HEIGHT * scale) / 2,
				});
				stage.batchDraw();
			}

			// Get center position of viewport
			function getViewportCenter() {
				const scale = stage.scaleX();
				const centerX = (stage.width() / 2 - stage.x()) / scale;
				const centerY = (stage.height() / 2 - stage.y()) / scale;
				return { x: centerX, y: centerY };
			}

			// Create entity
			async function createEntity() {
				const { value: name } = await Swal.fire({
					title: "Nueva Entidad",
					input: "text",
					inputLabel: "Nombre de la entidad",
					inputPlaceholder: "Ej: Usuario, Producto...",
					showCancelButton: true,
					confirmButtonText: "Crear",
					cancelButtonText: "Cancelar",
					inputValidator: (value) => {
						if (!value) {
							return "Debes ingresar un nombre";
						}
						if (value.length > 40) {
							return "El nombre no puede tener m치s de 40 caracteres";
						}
					},
				});

				if (name) {
					const center = getViewportCenter();
					const entity = {
						id: Date.now(),
						name: name.replaceAll(" ", "_"),
						x: center.x,
						y: center.y,
						properties: [],
					};

					entities.push(entity);
					drawEntity(entity);
					layer.batchDraw();
				}
			}

			// Draw entity
			function drawEntity(entity) {
				const group = new Konva.Group({
					x: entity.x,
					y: entity.y,
					draggable: true,
					id: `entity-${entity.id}`,
				});

				group.on("dragmove", function () {
					const pos = this.position();
					const newX = Math.max(0, Math.min(CANVAS_WIDTH - 150, pos.x));
					const newY = Math.max(0, Math.min(CANVAS_HEIGHT - 80, pos.y));
					this.position({ x: newX, y: newY });
					entity.x = newX;
					entity.y = newY;
					updateConnections();
				});

				const rect = new Konva.Rect({
					width: 150,
					height: 80,
					fill: "#3b82f6",
					stroke: "#1e40af",
					strokeWidth: 2,
					cornerRadius: 8,
					shadowColor: "black",
					shadowBlur: 10,
					shadowOpacity: 0.2,
					shadowOffset: { x: 0, y: 2 },
				});

				const text = new Konva.Text({
					text: entity.name,
					fontSize: 16,
					fontFamily: "Inter, sans-serif",
					fill: "white",
					width: 150,
					height: 80,
					align: "center",
					verticalAlign: "middle",
					fontStyle: "bold",
				});

				group.add(rect);
				group.add(text);

				// Context menu and click handlers
				group.on("contextmenu click", (e) => {
					e.evt.preventDefault();
					showEntityContextMenu(entity, e.evt.clientX, e.evt.clientY);
				});

				layer.add(group);
				group.moveToTop(); // Ensure new elements appear on top
			}

			// Show entity context menu
			function showEntityContextMenu(entity, x, y) {
				removeContextMenus();

				const menu = document.createElement("div");
				menu.className = "context-menu";
				menu.style.left = x + "px";
				menu.style.top = y + "px";

				menu.innerHTML = `
			     <div class="context-menu-item" data-action="edit">
			         <i class="fas fa-edit"></i> Editar Nombre
			     </div>
			     <div class="context-menu-item" data-action="add-property">
			         <i class="fas fa-plus-circle"></i> Agregar Propiedad
			     </div>
			     <div class="context-menu-divider"></div>
			     <div class="context-menu-item" data-action="delete" style="color: #ef4444;">
			         <i class="fas fa-trash"></i> Eliminar
			     </div>
			 `;

				document.body.appendChild(menu);

				menu.querySelectorAll(".context-menu-item").forEach((item) => {
					item.addEventListener("click", async () => {
						const action = item.getAttribute("data-action");
						removeContextMenus();

						if (action === "edit") {
							await editEntityName(entity);
						} else if (action === "add-property") {
							await addPropertyToEntity(entity);
						} else if (action === "delete") {
							deleteEntity(entity);
						}
					});
				});

				setTimeout(() => {
					document.addEventListener("click", removeContextMenus, { once: true });
				}, 100);
			}

			// Edit entity name
			async function editEntityName(entity) {
				const { value: newName } = await Swal.fire({
					title: "Editar Entidad",
					input: "text",
					inputValue: entity.name,
					inputLabel: "Nombre de la entidad",
					showCancelButton: true,
					confirmButtonText: "Guardar",
					cancelButtonText: "Cancelar",
					inputValidator: (value) => {
						if (!value) {
							return "El nombre no puede estar vac칤o";
						}
						if (value.length > 40) {
							return "El nombre no puede tener m치s de 40 caracteres";
						}
					},
				});

				if (newName) {
					entity.name = newName.replaceAll(" ", "_");

					// Find old group and destroy it
					const oldGroup = layer.findOne(`#entity-${entity.id}`);
					if (oldGroup) oldGroup.destroy();

					// Redraw the entity at the same position
					drawEntity(entity);

					// Update connections and layer
					updateConnections();
					layer.batchDraw();
				}
			}

			// Add property to entity
			async function addPropertyToEntity(entity) {
				const hasPrimaryKey = entity.properties.some((p) => p.isPrimaryKey);

				const { value: formValues } = await Swal.fire({
					title: "Nueva Propiedad",
					html: `
			         <div style="text-align: left;">
			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Nombre:</label>
			             <input id="prop-name" class="swal2-input" style="margin: 0 0 16px 0;" placeholder="Ej: id, nombre...">

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Tipo:</label>
			             <select id="prop-type" class="swal2-input" style="margin: 0 0 16px 0;">
			                 <option value="INT">INT</option>
			                 <option value="VARCHAR(255)">VARCHAR(255)</option>
			                 <option value="TEXT">TEXT</option>
			                 <option value="DATE">DATE</option>
			                 <option value="DATETIME">DATETIME</option>
			                 <option value="BOOLEAN">BOOLEAN</option>
			                 <option value="DECIMAL">DECIMAL</option>
			             </select>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-pk" ${hasPrimaryKey ? "disabled" : ""}>
			                     <span>Clave Primaria (PK)</span>
			                 </label>
			             </div>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-ai">
			                     <span>Auto Incremento</span>
			                 </label>
			             </div>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-unique">
			                     <span>칔nico</span>
			                 </label>
			             </div>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-nn" checked>
			                     <span>No Nulo</span>
			                 </label>
			             </div>
			         </div>
			     `,
					focusConfirm: false,
					showCancelButton: true,
					confirmButtonText: "Agregar",
					cancelButtonText: "Cancelar",
					preConfirm: () => {
						const name = document.getElementById("prop-name").value;
						if (!name) {
							Swal.showValidationMessage("Debes ingresar un nombre");
							return false;
						}
						if (name.length > 40) {
							Swal.showValidationMessage("El nombre no puede tener m치s de 40 caracteres");
							return false;
						}
						return {
							name: name.replaceAll(" ", "_"),
							type: document.getElementById("prop-type").value,
							isPrimaryKey: document.getElementById("prop-pk").checked,
							isAutoIncrement: document.getElementById("prop-ai").checked,
							isUnique: document.getElementById("prop-unique").checked,
							isNotNull: document.getElementById("prop-nn").checked,
						};
					},
				});

				if (formValues) {
					const property = {
						id: Date.now(),
						entityId: entity.id,
						...formValues,
					};

					entity.properties.push(property);

					const center = getViewportCenter();
					drawProperty(property, entity, center.x, center.y);
					layer.batchDraw();
				}
			}

			function drawProperty(property, entity, x, y) {
				const group = new Konva.Group({
					x: x || entity.x + 200,
					y: y || entity.y,
					draggable: true,
					id: `property-${property.id}`,
				});

				group.on("dragmove", function () {
					const pos = this.position();
					const newX = Math.max(0, Math.min(CANVAS_WIDTH - 250, pos.x));
					const newY = Math.max(0, Math.min(CANVAS_HEIGHT - 60, pos.y));
					this.position({ x: newX, y: newY });
					updateConnections();
				});

				// Temporary text to measure size
				const tempText = new Konva.Text({
					text: property.name,
					fontSize: 14,
					fontFamily: "Inter, sans-serif",
					fontStyle: property.isPrimaryKey ? "bold" : "normal",
					width: "auto", // max width
					wrap: "char", // wrap text
					ellipsis: true, // show ... if too long
				});

				const textWidth = tempText.width();
				const textHeight = tempText.height();
				const PADDING_X = 20;
				const PADDING_Y = 20;

				// Ellipse size based on text
				const ellipse = new Konva.Ellipse({
					radiusX: Math.min(textWidth / 2 + PADDING_X, 250 / 2),
					radiusY: textHeight / 2 + PADDING_Y,
					fill: "#fbbf24",
					stroke: "#d97706",
					strokeWidth: 2,
					shadowColor: "black",
					shadowBlur: 8,
					shadowOpacity: 0.15,
					shadowOffset: { x: 0, y: 2 },
				});

				// Text inside ellipse
				const text = new Konva.Text({
					text: property.name,
					fontSize: 14,
					fontFamily: "Inter, sans-serif",
					fill: "#1f2937",
					width: Math.min(textWidth, 250 - PADDING_X * 2), // wrap inside max width
					align: "center",
					verticalAlign: "middle",
					fontStyle: property.isPrimaryKey ? "bold" : "normal",
					textDecoration: property.isPrimaryKey ? "underline" : "",
				});

				// Center text inside ellipse
				text.offsetX(text.width() / 2);
				text.offsetY(text.height() / 2);

				group.add(ellipse);
				group.add(text);

				// Context menu
				group.on("contextmenu click", (e) => {
					e.evt.preventDefault();
					showPropertyContextMenu(property, entity, e.evt.clientX, e.evt.clientY);
				});

				layer.add(group);
				group.moveToTop();
				properties.push({ property, entity, group });

				// Create connection line
				createConnection(entity, group);
			}

			// Show property context menu
			function showPropertyContextMenu(property, entity, x, y) {
				removeContextMenus();

				const menu = document.createElement("div");
				menu.className = "context-menu";
				menu.style.left = x + "px";
				menu.style.top = y + "px";

				menu.innerHTML = `
			     <div class="context-menu-item" data-action="edit">
			         <i class="fas fa-edit"></i> Editar
			     </div>
			     <div class="context-menu-divider"></div>
			     <div class="context-menu-item" data-action="delete" style="color: #ef4444;">
			         <i class="fas fa-trash"></i> Eliminar
			     </div>
			 `;

				document.body.appendChild(menu);

				menu.querySelectorAll(".context-menu-item").forEach((item) => {
					item.addEventListener("click", async () => {
						const action = item.getAttribute("data-action");
						removeContextMenus();

						if (action === "edit") {
							await editProperty(property, entity);
						} else if (action === "delete") {
							deleteProperty(property, entity);
						}
					});
				});

				setTimeout(() => {
					document.addEventListener("click", removeContextMenus, { once: true });
				}, 100);
			}

			// Edit property
			async function editProperty(property, entity) {
				const hasPrimaryKey = entity.properties.some((p) => p.isPrimaryKey && p.id !== property.id);

				const { value: formValues } = await Swal.fire({
					title: "Editar Propiedad",
					html: `
			         <div style="text-align: left;">
			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Nombre:</label>
			             <input id="prop-name" class="swal2-input" style="margin: 0 0 16px 0;" value="${property.name}">

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Tipo:</label>
			             <select id="prop-type" class="swal2-input" style="margin: 0 0 16px 0;">
			                 <option value="INT" ${property.type === "INT" ? "selected" : ""}>INT</option>
			                 <option value="VARCHAR(255)" ${property.type === "VARCHAR(255)" ? "selected" : ""}>VARCHAR(255)</option>
			                 <option value="TEXT" ${property.type === "TEXT" ? "selected" : ""}>TEXT</option>
			                 <option value="DATE" ${property.type === "DATE" ? "selected" : ""}>DATE</option>
			                 <option value="DATETIME" ${property.type === "DATETIME" ? "selected" : ""}>DATETIME</option>
			                 <option value="BOOLEAN" ${property.type === "BOOLEAN" ? "selected" : ""}>BOOLEAN</option>
			                 <option value="DECIMAL" ${property.type === "DECIMAL" ? "selected" : ""}>DECIMAL</option>
			             </select>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-pk" ${property.isPrimaryKey ? "checked" : ""} ${hasPrimaryKey ? "disabled" : ""}>
			                     <span>Clave Primaria (PK)</span>
			                 </label>
			             </div>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-ai" ${property.isAutoIncrement ? "checked" : ""}>
			                     <span>Auto Incremento</span>
			                 </label>
			             </div>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-unique" ${property.isUnique ? "checked" : ""}>
			                     <span>칔nico</span>
			                 </label>
			             </div>

			             <div style="margin-bottom: 12px;">
			                 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
			                     <input type="checkbox" id="prop-nn" ${property.isNotNull ? "checked" : ""}>
			                     <span>No Nulo</span>
			                 </label>
			             </div>
			         </div>
			     `,
					focusConfirm: false,
					showCancelButton: true,
					confirmButtonText: "Guardar",
					cancelButtonText: "Cancelar",
					preConfirm: () => {
						const name = document.getElementById("prop-name").value;
						if (!name) {
							Swal.showValidationMessage("Debes ingresar un nombre");
							return false;
						}
						if (name.length > 40) {
							Swal.showValidationMessage("El nombre no puede tener m치s de 40 caracteres");
							return false;
						}
						return {
							name: name.replaceAll(" ", "_"),
							type: document.getElementById("prop-type").value,
							isPrimaryKey: document.getElementById("prop-pk").checked,
							isAutoIncrement: document.getElementById("prop-ai").checked,
							isUnique: document.getElementById("prop-unique").checked,
							isNotNull: document.getElementById("prop-nn").checked,
						};
					},
				});

				if (formValues) {
					Object.assign(property, formValues);

					// Find old property group and remove it
					const oldGroupIndex = properties.findIndex((p) => p.property.id === property.id);
					if (oldGroupIndex !== -1) {
						const oldGroup = properties[oldGroupIndex].group;
						oldGroup.destroy(); // removes it from the layer
						properties.splice(oldGroupIndex, 1); // remove from array
					}

					// Redraw the property with updated values
					drawProperty(property, entity, property.x, property.y);

					layer.batchDraw();
				}
			}

			// Delete property
			function deleteProperty(property, entity) {
				Swal.fire({
					title: "쮼liminar propiedad?",
					text: `Se eliminar치 la propiedad "${property.name}"`,
					icon: "warning",
					showCancelButton: true,
					confirmButtonText: "Eliminar",
					cancelButtonText: "Cancelar",
					confirmButtonColor: "#ef4444",
				}).then((result) => {
					if (result.isConfirmed) {
						entity.properties = entity.properties.filter((p) => p.id !== property.id);

						const propData = properties.find((p) => p.property.id === property.id);
						if (propData) {
							propData.group.destroy();
							properties = properties.filter((p) => p.property.id !== property.id);
						}

						connections = connections.filter((c) => {
							if (c.propertyId === property.id) {
								c.line.destroy();
								return false;
							}
							return true;
						});

						layer.batchDraw();
					}
				});
			}

			// Delete entity
			function deleteEntity(entity) {
				Swal.fire({
					title: "쮼liminar entidad?",
					text: `Se eliminar치 la entidad "${entity.name}" y todas sus propiedades`,
					icon: "warning",
					showCancelButton: true,
					confirmButtonText: "Eliminar",
					cancelButtonText: "Cancelar",
					confirmButtonColor: "#ef4444",
				}).then((result) => {
					if (result.isConfirmed) {
						// Remove entity
						const group = layer.findOne(`#entity-${entity.id}`);
						if (group) group.destroy();

						// Remove properties
						properties = properties.filter((p) => {
							if (p.entity.id === entity.id) {
								p.group.destroy();
								return false;
							}
							return true;
						});

						// Remove connections
						connections = connections.filter((c) => {
							if (c.entityId === entity.id) {
								c.line.destroy();
								return false;
							}
							return true;
						});

						// Remove relationships
						relationships = relationships.filter((r) => {
							if (r.fromEntity.id === entity.id || r.toEntity.id === entity.id) {
								const relGroup = layer.findOne(`#relationship-${r.id}`);
								if (relGroup) relGroup.destroy();

								r.lines.forEach((line) => line.destroy());
								r.cardinalityTexts.forEach((text) => text.destroy());
								return false;
							}
							return true;
						});

						entities = entities.filter((e) => e.id !== entity.id);
						layer.batchDraw();
					}
				});
			}

			// Create connection line between entity and property
			function createConnection(entity, propertyGroup) {
				const line = new Konva.Line({
					points: [],
					stroke: "#94a3b8",
					strokeWidth: 2,
					dash: [5, 5],
				});

				layer.add(line);
				line.moveToBottom();

				connections.push({
					entityId: entity.id,
					propertyId: propertyGroup.id().replace("property-", ""),
					line: line,
				});

				updateConnections();
			}

			// Update all connection lines
			function updateConnections() {
				connections.forEach((conn) => {
					const entityGroup = layer.findOne(`#entity-${conn.entityId}`);
					const propertyGroup = layer.findOne(`#property-${conn.propertyId}`);

					if (entityGroup && propertyGroup) {
						const entityPos = entityGroup.position();
						const propertyPos = propertyGroup.position();

						conn.line.points([entityPos.x + 75, entityPos.y + 40, propertyPos.x, propertyPos.y]);
					}
				});

				// Update relationship lines
				relationships.forEach((rel) => {
					updateRelationshipLines(rel);
				});

				layer.batchDraw();
			}

			// Create relationship
			async function createRelationship() {
				if (entities.length === 0) {
					Swal.fire({
						icon: "warning",
						title: "Sin entidades",
						text: "Necesitas al menos una entidad para crear una relaci칩n",
					});
					return;
				}

				const entityOptions = entities.map((e) => `<option value="${e.id}">${e.name}</option>`).join("");

				const { value: formValues } = await Swal.fire({
					title: "Nueva Relaci칩n",
					html: `
			         <div style="text-align: left;">
			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Nombre:</label>
			             <input id="rel-name" class="swal2-input" style="margin: 0 0 16px 0;" placeholder="Ej: tiene, pertenece...">

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Desde Entidad:</label>
			             <select id="rel-from" class="swal2-input" style="margin: 0 0 16px 0;">
			                 ${entityOptions}
			             </select>

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Hacia Entidad:</label>
			             <select id="rel-to" class="swal2-input" style="margin: 0 0 16px 0;">
			                 ${entityOptions}
			             </select>

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Cardinalidad:</label>
			             <select id="rel-card" class="swal2-input" style="margin: 0;">
			                 <option value="1:1">1:1 (Uno a Uno)</option>
			                 <option value="1:N">1:N (Uno a Muchos)</option>
			                 <option value="N:1">N:1 (Muchos a Uno)</option>
			                 <option value="N:M">N:M (Muchos a Muchos)</option>
			             </select>
			         </div>
			     `,
					focusConfirm: false,
					showCancelButton: true,
					confirmButtonText: "Crear",
					cancelButtonText: "Cancelar",
					preConfirm: () => {
						const name = document.getElementById("rel-name").value;
						if (!name) {
							Swal.showValidationMessage("Debes ingresar un nombre");
							return false;
						}
						if (name.length > 40) {
							Swal.showValidationMessage("El nombre no puede tener m치s de 40 caracteres");
							return false;
						}
						return {
							name: name.replaceAll(" ", "_"),
							fromId: Number.parseInt(document.getElementById("rel-from").value),
							toId: Number.parseInt(document.getElementById("rel-to").value),
							cardinality: document.getElementById("rel-card").value,
						};
					},
				});

				if (formValues) {
					const fromEntity = entities.find((e) => e.id === formValues.fromId);
					const toEntity = entities.find((e) => e.id === formValues.toId);

					const center = getViewportCenter();
					const relationship = {
						id: Date.now(),
						name: formValues.name,
						fromEntity: fromEntity,
						toEntity: toEntity,
						cardinality: formValues.cardinality,
						x: center.x,
						y: center.y,
						lines: [],
						cardinalityTexts: [],
					};

					relationships.push(relationship);
					drawRelationship(relationship);
					layer.batchDraw();
				}
			}

			function drawRelationship(relationship) {
				const group = new Konva.Group({
					x: relationship.x,
					y: relationship.y,
					draggable: true,
					id: `relationship-${relationship.id}`,
				});

				group.on("dragmove", function () {
					const pos = this.position();
					const newX = Math.max(50, Math.min(CANVAS_WIDTH - 50, pos.x));
					const newY = Math.max(50, Math.min(CANVAS_HEIGHT - 50, pos.y));
					this.position({ x: newX, y: newY });
					relationship.x = newX;
					relationship.y = newY;
					updateRelationshipLines(relationship);
				});

				// Max diamond dimensions
				const MAX_WIDTH = 220;
				const MAX_HEIGHT = 60;
				const PADDING_X = 20;
				const PADDING_Y = 10;

				// Temporary text to measure size
				const tempText = new Konva.Text({
					text: relationship.name,
					fontSize: 14,
					fontFamily: "Inter, sans-serif",
					fontStyle: "bold",
				});

				// Calculate diamond size based on text
				let diamondWidth = tempText.width() / 2 + PADDING_X;
				let diamondHeight = tempText.height() / 2 + PADDING_Y;

				// Apply max constraints
				diamondWidth = Math.max(60, Math.min(diamondWidth, MAX_WIDTH / 2));
				diamondHeight = Math.max(30, Math.min(diamondHeight, MAX_HEIGHT / 2));

				// Diamond shape
				const diamond = new Konva.Line({
					points: [
						0,
						-diamondHeight, // top
						diamondWidth,
						0, // right
						0,
						diamondHeight, // bottom
						-diamondWidth,
						0, // left
					],
					closed: true,
					fill: "#ec4899",
					stroke: "#be185d",
					strokeWidth: 2,
					shadowColor: "black",
					shadowBlur: 8,
					shadowOpacity: 0.15,
					shadowOffset: { x: 0, y: 2 },
				});

				// Responsive text inside diamond
				const text = new Konva.Text({
					text: relationship.name,
					fontSize: 14,
					fontFamily: "Inter, sans-serif",
					fontStyle: "bold",
					width: diamondWidth * 2 - 10,
					align: "center",
					wrap: "char",
					ellipsis: true,
				});

				// Center text
				// Must measure text after wrapping
				text.y(-text.height() / 2);
				text.x(-text.width() / 2);

				group.add(diamond);
				group.add(text);

				// Context menu
				group.on("contextmenu click", (e) => {
					e.evt.preventDefault();
					showRelationshipContextMenu(relationship, e.evt.clientX, e.evt.clientY);
				});

				layer.add(group);
				group.moveToTop();

				createRelationshipLines(relationship);
			}

			// Create relationship connection lines
			function createRelationshipLines(relationship) {
				// Line to fromEntity
				const line1 = new Konva.Line({
					points: [],
					stroke: "#64748b",
					strokeWidth: 2.5,
				});
				layer.add(line1);
				line1.moveToBottom();
				relationship.lines.push(line1);

				// Line to toEntity
				const line2 = new Konva.Line({
					points: [],
					stroke: "#64748b",
					strokeWidth: 2.5,
				});
				layer.add(line2);
				line2.moveToBottom();
				relationship.lines.push(line2);

				const [card1, card2] = relationship.cardinality.split(":");

				// Helper to create a hexagon+text group
				function createCardGroup(cardValue) {
					const group = new Konva.Group();

					const hex = new Konva.RegularPolygon({
						sides: 6,
						radius: 18,
						fill: "#f1f5f9",
						stroke: "#475569",
						strokeWidth: 1.5,
						shadowColor: "black",
						shadowBlur: 6,
						shadowOpacity: 0.2,
						shadowOffset: { x: 0, y: 1 },
					});

					const text = new Konva.Text({
						text: cardValue,
						fontSize: 14,
						fontFamily: "Inter, sans-serif",
						fill: "#1f2937",
						fontStyle: "bold",
						align: "center",
						verticalAlign: "middle",
					});

					// Center text inside hexagon
					text.offsetX(text.width() / 2);
					text.offsetY(text.height() / 2);

					group.add(hex);
					group.add(text);

					layer.add(group);
					return group;
				}

				const cardGroup1 = createCardGroup(card1);
				const cardGroup2 = createCardGroup(card2);

				relationship.cardinalityTexts.push(cardGroup1);
				relationship.cardinalityTexts.push(cardGroup2);

				updateRelationshipLines(relationship);
			}

			// Update relationship lines
			function updateRelationshipLines(relationship) {
				const relGroup = layer.findOne(`#relationship-${relationship.id}`);
				if (!relGroup) return;

				const relPos = relGroup.position();

				const fromGroup = layer.findOne(`#entity-${relationship.fromEntity.id}`);
				const toGroup = layer.findOne(`#entity-${relationship.toEntity.id}`);
				if (!fromGroup || !toGroup) return;

				const fromPos = fromGroup.position();
				const toPos = toGroup.position();

				const fromRect = fromGroup.findOne("Rect");
				const toRect = toGroup.findOne("Rect");
				const fromWidth = fromRect ? fromRect.width() : 150;
				const fromHeight = fromRect ? fromRect.height() : 80;
				const toWidth = toRect ? toRect.width() : 150;
				const toHeight = toRect ? toRect.height() : 80;

				// Diamond size
				const diamond = relGroup.findOne("Line");
				const diamondWidth = diamond ? Math.max(...diamond.points().filter((_, i) => i % 2 === 0)) : 50;
				const diamondHeight = diamond ? Math.max(...diamond.points().filter((_, i) => i % 2 !== 0)) : 50;

				// Detect self-relation
				const isSelfRelation = fromGroup === toGroup;

				// Update lines
				if (relationship.lines[0]) {
					if (isSelfRelation) {
						// curve line for self relation
						relationship.lines[0].points([fromPos.x + fromWidth / 2, fromPos.y + fromHeight / 2, relPos.x - diamondWidth / 2, relPos.y - diamondHeight / 2]);
					} else {
						relationship.lines[0].points([fromPos.x + fromWidth / 2, fromPos.y + fromHeight / 2, relPos.x, relPos.y]);
					}
				}

				if (relationship.lines[1]) {
					if (isSelfRelation) {
						relationship.lines[1].points([relPos.x + diamondWidth / 2, relPos.y - diamondHeight / 2, toPos.x + toWidth / 2, toPos.y + toHeight / 2]);
					} else {
						relationship.lines[1].points([relPos.x, relPos.y, toPos.x + toWidth / 2, toPos.y + toHeight / 2]);
					}
				}

				// Function to position cardinality groups along the line
				function positionCardinality(cardGroup, entityPos, entityWidth, entityHeight, side, isSelfRelation) {
					let dx, dy;
					if (isSelfRelation) {
						dx = side === "left" ? -diamondWidth / 2 : diamondWidth / 2;
						dy = 0;
					} else {
						dx = relPos.x - (entityPos.x + entityWidth / 2);
						dy = relPos.y - (entityPos.y + entityHeight / 2);
					}

					const len = Math.sqrt(dx * dx + dy * dy) || 1;
					const ux = dx / len;
					const uy = dy / len;

					const offset = Math.max(diamondWidth, diamondHeight) * 0.5;

					cardGroup.position({
						x: relPos.x - ux * offset - dx * 0.25,
						y: relPos.y - uy * offset - dy * 0.25,
					});
					cardGroup.moveToTop();
				}

				// Position first cardinality
				if (relationship.cardinalityTexts[0]) {
					positionCardinality(relationship.cardinalityTexts[0], fromPos, fromWidth, fromHeight, "left", isSelfRelation);
				}

				// Position second cardinality
				if (relationship.cardinalityTexts[1]) {
					positionCardinality(relationship.cardinalityTexts[1], toPos, toWidth, toHeight, "right", isSelfRelation);
				}
			}

			// Show relationship context menu
			function showRelationshipContextMenu(relationship, x, y) {
				removeContextMenus();

				const menu = document.createElement("div");
				menu.className = "context-menu";
				menu.style.left = x + "px";
				menu.style.top = y + "px";

				menu.innerHTML = `
			     <div class="context-menu-item" data-action="edit">
			         <i class="fas fa-edit"></i> Editar
			     </div>
			     <div class="context-menu-divider"></div>
			     <div class="context-menu-item" data-action="delete" style="color: #ef4444;">
			         <i class="fas fa-trash"></i> Eliminar
			     </div>
			 `;

				document.body.appendChild(menu);

				menu.querySelectorAll(".context-menu-item").forEach((item) => {
					item.addEventListener("click", async () => {
						const action = item.getAttribute("data-action");
						removeContextMenus();

						if (action === "edit") {
							await editRelationship(relationship);
						} else if (action === "delete") {
							deleteRelationship(relationship);
						}
					});
				});

				setTimeout(() => {
					document.addEventListener("click", removeContextMenus, { once: true });
				}, 100);
			}

			// Edit relationship
			async function editRelationship(relationship) {
				const entityOptions = entities.map((e) => `<option value="${e.id}" ${e.id === relationship.fromEntity.id ? "selected" : ""}>${e.name}</option>`).join("");

				const entityOptions2 = entities.map((e) => `<option value="${e.id}" ${e.id === relationship.toEntity.id ? "selected" : ""}>${e.name}</option>`).join("");

				const { value: formValues } = await Swal.fire({
					title: "Editar Relaci칩n",
					html: `
			         <div style="text-align: left;">
			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Nombre:</label>
			             <input id="rel-name" class="swal2-input" style="margin: 0 0 16px 0;" value="${relationship.name}">

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Desde Entidad:</label>
			             <select id="rel-from" class="swal2-input" style="margin: 0 0 16px 0;">
			                 ${entityOptions}
			             </select>

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Hacia Entidad:</label>
			             <select id="rel-to" class="swal2-input" style="margin: 0 0 16px 0;">
			                 ${entityOptions2}
			             </select>

			             <label style="display: block; margin-bottom: 8px; font-weight: 500;">Cardinalidad:</label>
			             <select id="rel-card" class="swal2-input" style="margin: 0;">
			                 <option value="1:1" ${relationship.cardinality === "1:1" ? "selected" : ""}>1:1 (Uno a Uno)</option>
			                 <option value="1:N" ${relationship.cardinality === "1:N" ? "selected" : ""}>1:N (Uno a Muchos)</option>
			                 <option value="N:1" ${relationship.cardinality === "N:1" ? "selected" : ""}>N:1 (Muchos a Uno)</option>
			                 <option value="N:M" ${relationship.cardinality === "N:M" ? "selected" : ""}>N:M (Muchos a Muchos)</option>
			             </select>
			         </div>
			     `,
					focusConfirm: false,
					showCancelButton: true,
					confirmButtonText: "Guardar",
					cancelButtonText: "Cancelar",
					preConfirm: () => {
						const name = document.getElementById("rel-name").value;
						if (!name) {
							Swal.showValidationMessage("Debes ingresar un nombre");
							return false;
						}
						if (name.length > 40) {
							Swal.showValidationMessage("El nombre no puede tener m치s de 40 caracteres");
							return false;
						}
						return {
							name: name.replaceAll(" ", "_"),
							fromId: Number.parseInt(document.getElementById("rel-from").value),
							toId: Number.parseInt(document.getElementById("rel-to").value),
							cardinality: document.getElementById("rel-card").value,
						};
					},
				});

				if (formValues) {
					Object.assign(relationship, {
						name: formValues.name,
						fromEntity: entities.find((e) => e.id === formValues.fromId),
						toEntity: entities.find((e) => e.id === formValues.toId),
						cardinality: formValues.cardinality,
					});

					// Find old group
					const oldGroup = layer.findOne(`#relationship-${relationship.id}`);
					if (oldGroup) {
						// Destroy all associated lines and texts first
						relationship.lines.forEach((line) => line.destroy());
						relationship.cardinalityTexts.forEach((text) => text.destroy());

						// Destroy the group itself
						oldGroup.destroy();
					}

					// Remove from relationships array
					relationships = relationships.filter((r) => r.id !== relationship.id);

					// Redraw relationship (preserve previous x/y)
					drawRelationship(relationship);

					// Update layer
					layer.batchDraw();
				}
			}

			// Delete relationship
			function deleteRelationship(relationship) {
				Swal.fire({
					title: "쮼liminar relaci칩n?",
					text: `Se eliminar치 la relaci칩n "${relationship.name}"`,
					icon: "warning",
					showCancelButton: true,
					confirmButtonText: "Eliminar",
					cancelButtonText: "Cancelar",
					confirmButtonColor: "#ef4444",
				}).then((result) => {
					if (result.isConfirmed) {
						const group = layer.findOne(`#relationship-${relationship.id}`);
						if (group) group.destroy();

						relationship.lines.forEach((line) => line.destroy());
						relationship.cardinalityTexts.forEach((text) => text.destroy());

						relationships = relationships.filter((r) => r.id !== relationship.id);
						layer.batchDraw();
					}
				});
			}

			// Show empty space context menu
			function showEmptySpaceContextMenu(x, y) {
				removeContextMenus();

				const menu = document.createElement("div");
				menu.className = "context-menu";
				menu.style.left = x + "px";
				menu.style.top = y + "px";

				menu.innerHTML = `
			     <div class="context-menu-item" data-action="entity">
			         <i class="fas fa-table"></i> Nueva Entidad
			     </div>
			     <div class="context-menu-item" data-action="relationship">
			         <i class="fas fa-link"></i> Nueva Relaci칩n
			     </div>
			 `;

				document.body.appendChild(menu);

				menu.querySelectorAll(".context-menu-item").forEach((item) => {
					item.addEventListener("click", () => {
						const action = item.getAttribute("data-action");
						removeContextMenus();

						if (action === "entity") {
							createEntity();
						} else if (action === "relationship") {
							createRelationship();
						}
					});
				});

				setTimeout(() => {
					document.addEventListener("click", removeContextMenus, { once: true });
				}, 100);
			}

			// Remove all context menus
			function removeContextMenus() {
				document.querySelectorAll(".context-menu").forEach((menu) => menu.remove());
			}

			// Check for errors
			function checkErrors() {
				const errors = [];

				// --- ENTITY-LEVEL CHECKS ---
				entities.forEach((entity) => {
					const props = entity.properties;

					// 1. Multiple primary keys
					const pkCount = props.filter((p) => p.isPrimaryKey).length;
					if (pkCount > 1) {
						errors.push({
							type: "error",
							title: "M칰ltiples Claves Primarias",
							message: `La entidad "${entity.name}" tiene ${pkCount} claves primarias. Solo debe tener una.`,
						});
					} else if (pkCount === 0 && props.length > 0) {
						errors.push({
							type: "warning",
							title: "Sin Clave Primaria",
							message: `La entidad "${entity.name}" no tiene clave primaria definida.`,
						});
					}

					// 2. No properties
					if (props.length === 0) {
						errors.push({
							type: "warning",
							title: "Entidad Sin Propiedades",
							message: `La entidad "${entity.name}" no tiene propiedades definidas.`,
						});
					}

					// 3. Duplicate property names
					const names = props.map((p) => p.name.toLowerCase());
					const duplicates = names.filter((n, i) => names.indexOf(n) !== i);
					if (duplicates.length > 0) {
						errors.push({
							type: "error",
							title: "Propiedades Duplicadas",
							message: `La entidad "${entity.name}" tiene propiedades duplicadas: ${[...new Set(duplicates)].join(", ")}`,
						});
					}

					// 4. Empty property names
					props.forEach((p) => {
						if (!p.name || p.name.trim() === "") {
							errors.push({
								type: "error",
								title: "Propiedad Vac칤a",
								message: `Una propiedad de "${entity.name}" no tiene nombre.`,
							});
						}
					});

					// 5. Missing data types (optional)
					props.forEach((p) => {
						if (!p.type) {
							errors.push({
								type: "warning",
								title: "Tipo de Dato Faltante",
								message: `La propiedad "${p.name}" de "${entity.name}" no tiene tipo de dato definido.`,
							});
						}
					});
				});

				// --- RELATIONSHIP-LEVEL CHECKS ---
				const relPairs = [];
				relationships.forEach((rel) => {
					const fromEntity = entities.find((e) => e.id === rel.fromEntity.id);
					const toEntity = entities.find((e) => e.id === rel.toEntity.id);

					// 1. Missing entities
					if (!fromEntity) {
						errors.push({
							type: "error",
							title: "Entidad Faltante",
							message: `La relaci칩n "${rel.name}" referencia una entidad 'from' que no existe.`,
						});
					}
					if (!toEntity) {
						errors.push({
							type: "error",
							title: "Entidad Faltante",
							message: `La relaci칩n "${rel.name}" referencia una entidad 'to' que no existe.`,
						});
					}

					// 2. Missing or invalid cardinality
					if (!rel.cardinality || !rel.cardinality.includes(":")) {
						errors.push({
							type: "warning",
							title: "Cardinalidad Faltante",
							message: `La relaci칩n "${rel.name}" no tiene cardinalidad correcta.`,
						});
					}

					// 3. Self-relation with missing cardinality
					if (fromEntity && toEntity && fromEntity.id === toEntity.id && (!rel.cardinality || !rel.cardinality.includes(":"))) {
						errors.push({
							type: "warning",
							title: "Relaci칩n Propia Sin Cardinalidad",
							message: `La relaci칩n "${rel.name}" sobre la misma entidad no tiene cardinalidad definida.`,
						});
					}

					// 4. Duplicate relationships
					const pairKey = [rel.fromEntity.id, rel.toEntity.id].sort().join("-");
					if (relPairs.includes(pairKey)) {
						errors.push({
							type: "warning",
							title: "Relaci칩n Duplicada",
							message: `Existen relaciones duplicadas entre las mismas entidades: "${rel.name}".`,
						});
					} else {
						relPairs.push(pairKey);
					}
				});

				// --- GENERAL CHECKS ---
				// Orphan properties (properties not attached to any entity)
				properties.forEach((p) => {
					if (!entities.find((e) => e.id === p.entity.id)) {
						errors.push({
							type: "error",
							title: "Propiedad Hu칠rfana",
							message: `La propiedad "${p.property.name}" no pertenece a ninguna entidad v치lida.`,
						});
					}
				});

				// Entities without relationships
				entities.forEach((e) => {
					const hasRel = relationships.some((r) => r.fromEntity.id === e.id || r.toEntity.id === e.id);
					if (!hasRel) {
						errors.push({
							type: "warning",
							title: "Entidad Aislada",
							message: `La entidad "${e.name}" no participa en ninguna relaci칩n.`,
						});
					}
				});

				return errors;
			}

			// Show errors modal
			function showErrors() {
				const errors = checkErrors();

				if (errors.length === 0) {
					Swal.fire({
						icon: "success",
						title: "Sin Errores",
						text: "El diagrama no tiene errores ni avisos.",
					});
					return;
				}

				const errorHTML = errors
					.map(
						(err) => `
			     <div class="error-item ${err.type}">
			         <div class="error-item-icon">
			             <i class="fas fa-${err.type === "error" ? "times-circle" : "exclamation-triangle"}"></i>
			         </div>
			         <div class="error-item-content">
			             <div class="error-item-title">${err.type === "error" ? "Error" : "Aviso"}: ${err.title}</div>
			             <div class="error-item-message">${err.message}</div>
			         </div>
			     </div>
			 `
					)
					.join("");

				Swal.fire({
					title: "Errores y Avisos",
					html: `<div style="text-align: left; max-height: 400px; overflow-y: auto;">${errorHTML}</div>`,
					width: 600,
					confirmButtonText: "Cerrar",
				});
			}

			// Export to SQL
			function exportToSQL() {
				let sql = "-- JaimeDiagramas - Exportaci칩n SQL\n";
				sql += `-- Generado: ${new Date().toLocaleString("es-ES")}\n\n`;

				// Create tables
				entities.forEach((entity) => {
					sql += `CREATE TABLE ${entity.name} (\n`;

					const columns = entity.properties.map((prop) => {
						let line = `    ${prop.name} ${prop.type}`;
						if (prop.isPrimaryKey) line += " PRIMARY KEY";
						if (prop.isAutoIncrement) line += " AUTO_INCREMENT";
						if (prop.isUnique) line += " UNIQUE";
						if (prop.isNotNull) line += " NOT NULL";
						return line;
					});

					sql += columns.join(",\n");
					sql += "\n);\n\n";
				});

				// Handle relationships
				relationships.forEach((rel) => {
					const [card1, card2] = rel.cardinality.split(":");

					if (card1 === "N" && card2 === "M") {
						// Many-to-Many: create junction table
						sql += `-- Relaci칩n N:M: ${rel.name}\n`;
						sql += `CREATE TABLE ${rel.name} (\n`;

						const fromPK = rel.fromEntity.properties.find((p) => p.isPrimaryKey);
						const toPK = rel.toEntity.properties.find((p) => p.isPrimaryKey);

						sql += `    ${rel.fromEntity.name}_${fromPK?.name || "id"} ${fromPK?.type || "INT"},\n`;
						sql += `    ${rel.toEntity.name}_${toPK?.name || "id"} ${toPK?.type || "INT"},\n`;
						sql += `    PRIMARY KEY (${rel.fromEntity.name}_${fromPK?.name || "id"}, ${rel.toEntity.name}_${toPK?.name || "id"}),\n`;
						sql += `    FOREIGN KEY (${rel.fromEntity.name}_${fromPK?.name || "id"}) REFERENCES ${rel.fromEntity.name}(${fromPK?.name || "id"}),\n`;
						sql += `    FOREIGN KEY (${rel.toEntity.name}_${toPK?.name || "id"}) REFERENCES ${rel.toEntity.name}(${toPK?.name || "id"})\n`;
						sql += ");\n\n";
					} else if (card2 === "N" || card2 === "M") {
						// One-to-Many
						sql += `-- Relaci칩n 1:N: ${rel.name}\n`;
						const fromPK = rel.fromEntity.properties.find((p) => p.isPrimaryKey);
						sql += `ALTER TABLE ${rel.toEntity.name}\n`;
						sql += `ADD COLUMN ${rel.fromEntity.name}_${fromPK?.name || "id"} ${fromPK?.type || "INT"},\n`;
						sql += `ADD FOREIGN KEY (${rel.fromEntity.name}_${fromPK?.name || "id"}) REFERENCES ${rel.fromEntity.name}(${fromPK?.name || "id"});\n\n`;
					} else {
						// One-to-One
						sql += `-- Relaci칩n 1:1: ${rel.name}\n`;
						const fromPK = rel.fromEntity.properties.find((p) => p.isPrimaryKey);
						sql += `ALTER TABLE ${rel.toEntity.name}\n`;
						sql += `ADD COLUMN ${rel.fromEntity.name}_${fromPK?.name || "id"} ${fromPK?.type || "INT"} UNIQUE,\n`;
						sql += `ADD FOREIGN KEY (${rel.fromEntity.name}_${fromPK?.name || "id"}) REFERENCES ${rel.fromEntity.name}(${fromPK?.name || "id"});\n\n`;
					}
				});

				// Show modal with SQL
				Swal.fire({
					title: "Exportar SQL",
					html: `
			         <textarea id="sql-output" readonly style="width: 100%; height: 400px; font-family: monospace; font-size: 12px; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; background: #f9fafb;">${sql}</textarea>
			         <div style="margin-top: 12px; display: flex; gap: 8px;">
			             <button id="copy-sql-btn" class="swal2-confirm swal2-styled" style="flex: 1;">
			                 <i class="fas fa-copy"></i> Copiar
			             </button>
			             <button id="download-sql-btn" class="swal2-confirm swal2-styled" style="flex: 1; background: #10b981;">
			                 <i class="fas fa-download"></i> Descargar
			             </button>
			         </div>
			     `,
					showConfirmButton: false,
					showCloseButton: true,
					width: 700,
					didOpen: () => {
						document.getElementById("copy-sql-btn").addEventListener("click", () => {
							const textarea = document.getElementById("sql-output");
							textarea.select();
							document.execCommand("copy");
							Swal.showValidationMessage("춰Copiado al portapapeles!");
							setTimeout(() => Swal.resetValidationMessage(), 2000);
						});

						document.getElementById("download-sql-btn").addEventListener("click", () => {
							const blob = new Blob([sql], { type: "text/plain" });
							const link = document.createElement("a");
							link.download = "diagrama.sql";
							link.href = URL.createObjectURL(blob);
							link.click();
						});
					},
				});
			}

			// Event listeners
			document.getElementById("addEntityBtn").addEventListener("click", createEntity);
			document.getElementById("addRelationshipBtn").addEventListener("click", createRelationship);
			document.getElementById("resetViewBtn").addEventListener("click", centerView);
			document.getElementById("errorsBtn").addEventListener("click", showErrors);
			document.getElementById("exportSQLBtn").addEventListener("click", exportToSQL);

			// Initialize
			initStage();
		</script>
	</body>
</html>
